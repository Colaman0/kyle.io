<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://colaman0.github.io/kylelin/</id>
    <title>Kyle</title>
    <updated>2020-04-09T07:27:47.533Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://colaman0.github.io/kylelin/"/>
    <link rel="self" href="https://colaman0.github.io/kylelin/atom.xml"/>
    <subtitle>且视他人之疑目如盏盏鬼火</subtitle>
    <logo>https://colaman0.github.io/kylelin/images/avatar.png</logo>
    <icon>https://colaman0.github.io/kylelin/favicon.ico</icon>
    <rights>All rights reserved 2020, Kyle</rights>
    <entry>
        <title type="html"><![CDATA[ArrayMap源码解析]]></title>
        <id>https://colaman0.github.io/kylelin/post/arraymap-yuan-ma-jie-xi/</id>
        <link href="https://colaman0.github.io/kylelin/post/arraymap-yuan-ma-jie-xi/">
        </link>
        <updated>2020-04-09T07:03:49.000Z</updated>
        <content type="html"><![CDATA[<h4 id="上一篇文章提到了sparsearray和hashmap的关系与sparsearray同样用于改进hashmap效率的还有arraymap当然这两个类都是在特定情况下用于改进效率并不是任何情况下都优于hashmap下面将会一步步讲解arraymap的内部解构以及代码的组成是什么样的">上一篇文章提到了<code>SparseArray</code>和<code>HashMap</code>的关系，与<code>SparseArray</code>同样用于改进<code>HashMap</code>效率的还有<code>ArrayMap</code>，当然这两个类都是在特定情况下用于改进效率，并不是任何情况下都优于<code>HashMap</code>，下面将会一步步讲解<code>ArrayMap</code>的内部解构以及代码的组成是什么样的</h4>
<hr>
<h3 id="1-初始化">1. 初始化</h3>
<pre><code class="language-java">  // 传入初始容量
  public ArrayMap(int capacity) {
      this(capacity, false);
  }
  
  public ArrayMap(int capacity, boolean identityHashCode) {
      mIdentityHashCode = identityHashCode;

      // 根据传入的初始容量给`mArray` `mHashes`两个数组初始化
      if (capacity &lt; 0) {
          mHashes = EMPTY_IMMUTABLE_INTS;
          mArray = EmptyArray.OBJECT;
      } else if (capacity == 0) {
          mHashes = EmptyArray.INT;
          mArray = EmptyArray.OBJECT;
      } else {
          allocArrays(capacity);
      }
      mSize = 0;
  }
</code></pre>
<h3 id="2-put操作">2. <code>put</code>操作</h3>
<blockquote>
<p><code>put</code>相关的代码比较长，涉及到的逻辑也比较多，在这其中也会设计到扩容以及缓存的优化操作</p>
</blockquote>
<pre><code class="language-java">@Override
public V put(K key, V value) {
    // 记录下当前长度
    final int osize = mSize;
    final int hash;
    int index;
    // 如果传入的key为null，那么hash值默认为0，并且indexOfNull会通过二分查找
    // 返回一个下标，至于具体返回值情况可以看下面的代码分析
    if (key == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        // 计算出key的hash值并且计算出对应下标
        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();
        index = indexOf(key, hash);
    }
    // 如果下标大于0，也就是说key是存在的，那么直接更新对应的value
    if (index &gt;= 0) {
        // 因为array是一个键值对占两个位置，比如0和1存放的是key和对应的value
        // 所以这里对index左移一位并且+1
        index = (index&lt;&lt;1) + 1;
        // 把旧的值更新并且返回
        final V old = (V)mArray[index];
        mArray[index] = value;
        return old;
    }

    index = ~index;
    // 判断现有长度和hash数组的长度，去进行扩容操作
    if (osize &gt;= mHashes.length) {
        // 计算出扩容后的数组长度
        final int n = osize &gt;= (BASE_SIZE*2) ? (osize+(osize&gt;&gt;1))
                : (osize &gt;= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE);

        if (DEBUG) Log.d(TAG, &quot;put: grow from &quot; + mHashes.length + &quot; to &quot; + n);
        
        // 记录当前数组
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        
        // 对mHashes mArray两个数组进行扩容操作
        allocArrays(n);

        // 检查长度避免多线程操作了map
        if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {
            throw new ConcurrentModificationException();
        }
        
        // 把旧的数组移动到扩容后的数组
        if (mHashes.length &gt; 0) {
            if (DEBUG) Log.d(TAG, &quot;put: copy 0-&quot; + osize + &quot; to 0&quot;);
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        
        // 缓存无用的数组
        freeArrays(ohashes, oarray, osize);
    }
    
    // 当下标是在中间的时候，把index后面(包括index)的所有数据往后移动一位
    // 然后再把index对应的数据更新就达到了插入的操作
    if (index &lt; osize) {
        if (DEBUG) Log.d(TAG, &quot;put: move &quot; + index + &quot;-&quot; + (osize-index)
                + &quot; to &quot; + (index+1));
        System.arraycopy(mHashes, index, mHashes, index + 1, osize - index);
        System.arraycopy(mArray, index &lt;&lt; 1, mArray, (index + 1) &lt;&lt; 1, (mSize - index) &lt;&lt; 1);
    }

    if (CONCURRENT_MODIFICATION_EXCEPTIONS) {
        if (osize != mSize || index &gt;= mHashes.length) {
            throw new ConcurrentModificationException();
        }
    }
    // 更新对应index的值，把size+1记录个数
    mHashes[index] = hash;
    mArray[index&lt;&lt;1] = key;
    mArray[(index&lt;&lt;1)+1] = value;
    mSize++;
    return null;
}

int indexOf(Object key, int hash) {
    final int N = mSize;

    // Important fast case: if nothing is in here, nothing to look for.
    // 当前长度为0的时候直接对0取反，也就是返回了-1
    if (N == 0) {
        return ~0;
    }
    // 二分查找找到hash值要插入的下标
    int index = binarySearchHashes(mHashes, N, hash);

    // If the hash code wasn't found, then we have no entry for this key.
    // binarySearchHashes里会把index取反，在put的时候也会再取反一次
    if (index &lt; 0) {
        return index;
    }

    // If the key at the returned index matches, that's what we want.
    // 如果根据找到的index在mArray里的key值也是相同的就可以直接返回
    if (key.equals(mArray[index&lt;&lt;1])) {
        return index;
    }

    // Search for a matching key after the index.
    // 如果没找到，那么先向后查找再向前查找有没有对应的键值对存在
    // 因为上面的二分查找有可能会漏了相同hash值的key，也就是说不同key但是hash值相同
    // 这个时候直接用index去找可能会漏查，因为相同hash值的时候会插入到index，数据依次往后移
    // 所以这里先往后查找，再往前查找
    int end;
    for (end = index + 1; end &lt; N &amp;&amp; mHashes[end] == hash; end++) {
        if (key.equals(mArray[end &lt;&lt; 1])) return end;
    }

    // Search for a matching key before the index.
    for (int i = index - 1; i &gt;= 0 &amp;&amp; mHashes[i] == hash; i--) {
        if (key.equals(mArray[i &lt;&lt; 1])) return i;
    }

    // Key not found -- return negative value indicating where a
    // new entry for this key should go.  We use the end of the
    // hash chain to reduce the number of array entries that will
    // need to be copied when inserting.
    // 返回 ~0
    return ~end;
}

// 和indexof方法的区别在于代码的判断中把hash换成0，把key换成了null，其他逻辑不变
int indexOfNull() {
    final int N = mSize;

    // Important fast case: if nothing is in here, nothing to look for.
    if (N == 0) {
        return ~0;
    }

    int index = binarySearchHashes(mHashes, N, 0);

    // If the hash code wasn't found, then we have no entry for this key.
    if (index &lt; 0) {
        return index;
    }

    // If the key at the returned index matches, that's what we want.
    if (null == mArray[index&lt;&lt;1]) {
        return index;
    }

    // Search for a matching key after the index.
    int end;
    for (end = index + 1; end &lt; N &amp;&amp; mHashes[end] == 0; end++) {
        if (null == mArray[end &lt;&lt; 1]) return end;
    }

    // Search for a matching key before the index.
    for (int i = index - 1; i &gt;= 0 &amp;&amp; mHashes[i] == 0; i--) {
        if (null == mArray[i &lt;&lt; 1]) return i;
    }

    // Key not found -- return negative value indicating where a
    // new entry for this key should go.  We use the end of the
    // hash chain to reduce the number of array entries that will
    // need to be copied when inserting.
    return ~end;
}
</code></pre>
<h5 id="依照代码可以看出arraymap在put数据的时候会先将keyhash之后把找出hash值在hash数组的位置然后对应的把value插入到对应的下标而hash数组中的顺序是升序排的所以marray中的键值对不是按put的顺序">依照代码可以看出，<code>ArrayMap</code>在<code>put</code>数据的时候会先将<code>key</code>hash之后把找出hash值在hash数组的位置，然后对应的把<code>value</code>插入到对应的下标，而<code>hash数组</code>中的顺序是升序排的，所以<code>mArray</code>中的键值对不是按<code>put</code>的顺序。</h5>
<hr>
<h5 id="上面还提到了一个扩容allocarrays以及缓存freearrays的方法也是arraymap一大特色">上面还提到了一个扩容<code>allocArrays</code>以及缓存<code>freeArrays</code>的方法，也是<code>ArrayMap</code>一大特色</h5>
<pre><code class="language-java">@SuppressWarnings(&quot;ArrayToString&quot;)
private void allocArrays(final int size) {
    // 先判断size，因为arraymap只对4/8的长度做优化
    if (size == (BASE_SIZE*2)) {
        synchronized (SimpleArrayMap.class) {
            // mTwiceBaseCache是一个缓存的数组，默认为null，如果有缓存的数组就拿来用
            if (mTwiceBaseCache != null) {
                // 先把mTwiceBaseCache保存到array
                final Object[] array = mTwiceBaseCache;
                // 把原本存放键值对的数组设为新的array，达到数组扩容的目的
                mArray = array;
                // 把缓存节点指向当前数组的第0个元素，把mHash数组指向第1个元素
                mTwiceBaseCache = (Object[])array[0];
                mHashes = (int[])array[1];
                // 再清空数组，这样mArray指向的就是一个长度为size的空数组
                array[0] = array[1] = null;
                mTwiceBaseCacheSize--;
                if (DEBUG) System.out.println(TAG + &quot; Retrieving 2x cache &quot; + mHashes
                        + &quot; now have &quot; + mTwiceBaseCacheSize + &quot; entries&quot;);
                return;
            }
        }
    } else if (size == BASE_SIZE) {
        // 逻辑同上
        synchronized (SimpleArrayMap.class) {
            if (mBaseCache != null) {
                final Object[] array = mBaseCache;
                mArray = array;
                mBaseCache = (Object[])array[0];
                mHashes = (int[])array[1];
                array[0] = array[1] = null;
                mBaseCacheSize--;
                if (DEBUG) System.out.println(TAG + &quot; Retrieving 1x cache &quot; + mHashes
                        + &quot; now have &quot; + mBaseCacheSize + &quot; entries&quot;);
                return;
            }
        }
    }

    mHashes = new int[size];
    mArray = new Object[size&lt;&lt;1];
}

@SuppressWarnings(&quot;ArrayToString&quot;)
private static void freeArrays(final int[] hashes, final Object[] array, final int size) {
    // 先判断传入长度，决定要不要进行缓存优化
    if (hashes.length == (BASE_SIZE*2)) {
        synchronized (SimpleArrayMap.class) {
            // 达到缓存次数上限就不再缓存
            if (mTwiceBaseCacheSize &lt; CACHE_SIZE) {
                // 把传入的数组第0存放当前缓存节点，把1用来存放hash数组
                array[0] = mTwiceBaseCache;
                array[1] = hashes;
                // 把其他下标的数据清空
                for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) {
                    array[i] = null;
                }
                // 再把缓存节点指向传入的array
                // 也就是说这里面是把传入的数组当成了新的缓存节点，然后把旧的缓存节点存放在了第0个元素
                // hash数组放在第1个元素
                mTwiceBaseCache = array;
                mTwiceBaseCacheSize++;
                if (DEBUG) System.out.println(TAG + &quot; Storing 2x cache &quot; + array
                        + &quot; now have &quot; + mTwiceBaseCacheSize + &quot; entries&quot;);
            }
        }
    } else if (hashes.length == BASE_SIZE) {
        // 逻辑同上
        synchronized (SimpleArrayMap.class) {
            if (mBaseCacheSize &lt; CACHE_SIZE) {
                array[0] = mBaseCache;
                array[1] = hashes;
                for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) {
                    array[i] = null;
                }
                mBaseCache = array;
                mBaseCacheSize++;
                if (DEBUG) System.out.println(TAG + &quot; Storing 1x cache &quot; + array
                        + &quot; now have &quot; + mBaseCacheSize + &quot; entries&quot;);
            }
        }
    }
}
</code></pre>
<h5 id="这里可能有的人会比较困惑这两个方法的逻辑和作用实际上扩容以及缓存的逻辑分成以下几步">这里可能有的人会比较困惑这两个方法的逻辑和作用，实际上扩容以及缓存的逻辑分成以下几步</h5>
<ol>
<li>put的过程中判断数组长度是否足够，如果需要扩容，会计算出扩容后的长度，然后先保存现有的<code>mArray</code>和<code>mHashs</code></li>
<li>扩容的时候如果长度是符合缓存优化长度的，就会尝试去找缓存节点，如果有缓存数组<code>（用array代替）</code>可以用，那就用临时变量把先取出0和1两个下标的元素保存起来，然后<code>array</code>的0和1设成null，这样就可以拿到一个符合长度的数组用来存放<code>mArray</code>的数据，然后下标1的数组给<code>mHashs</code>用，也就是是说原有的缓存节点数组中<code>0</code>会变成新的缓存节点，<code>1</code>会给<code>mHash</code>复用，整个数组<code>array</code>给<code>mArray</code>复用</li>
<li>当空余位置比较多的时候，会尝试缩短数组长度节省空间，同样先是判断当前有多少个数组，符合优化长度的才会试着去缓存，并且缓存次数不能超过<code>10</code>次，然后把当前数组的<code>0</code>和<code>1</code>两个元素分别指向缓存节点以及当前的<code>hash</code>值数组，然后把其他元素清空，把缓存节点指向当前元素，也就是说每一次缓存会把缓存节点指向自身，并且自身<code>array</code>的<code>0</code>保存原有的缓存节点，1保存当前的<code>hash数组</code></li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2020/4/9/1715ce5e3f9d52fd?w=847&amp;h=787&amp;f=png&amp;s=302914" alt="" loading="lazy"></figure>
<h5 id="借用网上的一张图缓存数组会保存上一个缓存数组节点以及当前hash数组然后复用的时候就拿当前数组来用这样通过下标1可以得到一个hash数组然后清空之后就得到一个可以给marray复用的数组然后把缓存节点指向下标0更新缓存节点这样就完成了缓存复用的流程">借用网上的一张图，缓存数组会保存上一个缓存数组节点以及当前hash数组，然后复用的时候就拿当前数组来用，这样通过下标<code>1</code>可以得到一个hash数组，然后清空之后就得到一个可以给<code>mArray</code>复用的数组，然后把缓存节点指向下标<code>0</code>更新缓存节点，这样就完成了缓存复用的流程。</h5>
<h5 id="而缓存的时候也是同样的方式把mhash数组保存在了marray数组的第1个元素中把原有的缓存节点保存在下标0中然后把缓存节点指向当前array完成缓存数组的更新以及叠加">而缓存的时候也是同样的方式，把<code>mHash</code>数组保存在了<code>mArray</code>数组的第<code>1</code>个元素中，把原有的缓存节点保存在下标<code>0</code>中，然后把缓存节点指向当前array，完成缓存数组的更新以及叠加。</h5>
<blockquote>
<p>一般情况下都是先扩容再检查缓存节点，所以相当于是给把数据换到一个扩容<code>size</code>的新数组，然后把原本的数组加到缓存链中去。还有就是<code>clear</code> <code>remove</code>这种操作</p>
</blockquote>
<hr>
<h3 id="3-remove操作">3. remove操作</h3>
<pre><code class="language-java">@Override
public V remove(Object key) {
    // 找到对应key的下标之后再调用removeAt
    final int index = indexOfKey(key);
    if (index &gt;= 0) {
        return removeAt(index);
    }
    return null;
}

// 也是用到了indexOf和indexOfNull两个方法，具体逻辑在上面有提到
public int indexOfKey(Object key) {
        return key == null ? indexOfNull()
                : indexOf(key, mIdentityHashCode ? System.identityHashCode(key) : key.hashCode());
    }


public V removeAt(int index) {
    // 先检查数据合法性
    if (index &gt;= mSize &amp;&amp; UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // The array might be slightly bigger than mSize, in which case, indexing won't fail.
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    
    final Object old = mArray[(index &lt;&lt; 1) + 1];
    final int osize = mSize;
    final int nsize;
    
    // 如果原有长度只有1/0，那直接清空数组和数据就行了，并且会检查一下当前数组是否可以添加到缓存中去
    if (osize &lt;= 1) {
        // Now empty.
        if (DEBUG) Log.d(TAG, &quot;remove: shrink from &quot; + mHashes.length + &quot; to 0&quot;);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        freeArrays(ohashes, oarray, osize);
        nsize = 0;
    } else {
        nsize = osize - 1;
        // 判断一下map中数据长度和数组的长度，如果数据个数不到数组长度的1/3，那么重新分配数组
        if (mHashes.length &gt; (BASE_SIZE*2) &amp;&amp; mSize &lt; mHashes.length/3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            // 重新计算数组长度节省空间
            final int n = osize &gt; (BASE_SIZE*2) ? (osize + (osize&gt;&gt;1)) : (BASE_SIZE*2);

            if (DEBUG) Log.d(TAG, &quot;remove: shrink from &quot; + mHashes.length + &quot; to &quot; + n);

            // 保存旧数据
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            // 重新分配数组
            allocArrays(n);
            
            // 检查数据避免多线程操作的时候出现问题
            if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {
                throw new ConcurrentModificationException();
            }
            
            // 这里remove数据的方式是复制index前以及后的数据，跳过index
            if (index &gt; 0) {
                if (DEBUG) Log.d(TAG, &quot;remove: copy from 0-&quot; + index + &quot; to 0&quot;);
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index &lt;&lt; 1);
            }
            if (index &lt; nsize) {
                if (DEBUG) Log.d(TAG, &quot;remove: copy from &quot; + (index+1) + &quot;-&quot; + nsize
                        + &quot; to &quot; + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(oarray, (index + 1) &lt;&lt; 1, mArray, index &lt;&lt; 1,
                        (nsize - index) &lt;&lt; 1);
            }
        } else {
            // 这里逻辑是不涉及重新分配数组的，并且检查一下下标合法性
            if (index &lt; nsize) {
                if (DEBUG) Log.d(TAG, &quot;remove: move &quot; + (index+1) + &quot;-&quot; + nsize
                        + &quot; to &quot; + index);
                // 直接把index后的数据都复制往前移一位
                System.arraycopy(mHashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(mArray, (index + 1) &lt;&lt; 1, mArray, index &lt;&lt; 1,
                        (nsize - index) &lt;&lt; 1);
            }
            // 因为上面的操作把数据都复制了一份，这样会多出最后一个元素，所以要把最后一个设成null
            // 这样就完成了对index的remove
            mArray[nsize &lt;&lt; 1] = null;
            mArray[(nsize &lt;&lt; 1) + 1] = null;
        }
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {
        throw new ConcurrentModificationException();
    }
    // 更新数据长度
    mSize = nsize;
    return (V)old;
}
</code></pre>
<h3 id="4-append-putall">4. <code>append</code> <code>putAll</code></h3>
<pre><code class="language-java">
public void append(K key, V value) {
    // append默认是添加到末尾
    int index = mSize;
    // 根据key算出hash值
    final int hash = key == null ? 0
            : (mIdentityHashCode ? System.identityHashCode(key) : key.hashCode());
    
        
    // 检查index的合法性，做一些判断
    if (index &gt;= mHashes.length) {
        throw new IllegalStateException(&quot;Array is full&quot;);
    }
    
    // 找到位置存放，但是hash值没有按升序排列的时候，会打印异常然后用put去存放
    if (index &gt; 0 &amp;&amp; mHashes[index-1] &gt; hash) {
        RuntimeException e = new RuntimeException(&quot;here&quot;);
        e.fillInStackTrace();
        Log.w(TAG, &quot;New hash &quot; + hash
                + &quot; is before end of array hash &quot; + mHashes[index-1]
                + &quot; at index &quot; + index + &quot; key &quot; + key, e);
        put(key, value);
        return;
    }
    
    // 如果index合法并且hash值也合法，直接把数据加到末尾
    mSize = index+1;
    mHashes[index] = hash;
    index &lt;&lt;= 1;
    mArray[index] = key;
    mArray[index+1] = value;
}
    
/**
 * Perform a {@link #put(Object, Object)} of all key/value pairs in &lt;var&gt;array&lt;/var&gt;
 * @param array The array whose contents are to be retrieved.
 */
public void putAll(ArrayMap&lt;? extends K, ? extends V&gt; array) {
    final int N = array.mSize;
    // 先确定容量是否足够
    ensureCapacity(mSize + N);

    // map是空的时候直接把数据都复制过去
    if (mSize == 0) {
        if (N &gt; 0) {
            System.arraycopy(array.mHashes, 0, mHashes, 0, N);
            System.arraycopy(array.mArray, 0, mArray, 0, N&lt;&lt;1);
            mSize = N;
        }
    } else {
        // 不为空的时候for循环使用put
        for (int i=0; i&lt;N; i++) {
            put(array.keyAt(i), array.valueAt(i));
        }
    }
}

public void ensureCapacity(int minimumCapacity) {
    final int osize = mSize;
    if (mHashes.length &lt; minimumCapacity) {
        // 需要扩容的时候照样是保存旧数据然后去扩容，复制数据，接着缓存数组
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(minimumCapacity);
        if (mSize &gt; 0) {
            System.arraycopy(ohashes, 0, mHashes, 0, osize);
            System.arraycopy(oarray, 0, mArray, 0, osize&lt;&lt;1);
        }
        freeArrays(ohashes, oarray, osize);
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; mSize != osize) {
        throw new ConcurrentModificationException();
    }
}
</code></pre>
<h3 id="5-setvalueat">5. setValueAt</h3>
<pre><code class="language-java">public V setValueAt(int index, V value) {
    // 先检查index是否合法
    if (index &gt;= mSize &amp;&amp; UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // The array might be slightly bigger than mSize, in which case, indexing won't fail.
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    // 把对应index的value更新，然后返回旧的value，这里hash值不需要改变
    index = (index &lt;&lt; 1) + 1;
    V old = (V)mArray[index];
    mArray[index] = value;
    return old;
}
</code></pre>
<hr>
<h3 id="总结">总结</h3>
<ul>
<li><code>ArrayMap</code>中有两个数组来存放数据，<code>mArray</code>存放键值对数据，<code>mHashs</code>存放键的hash值。</li>
<li>查找下标的时候用二分法去找到插入的地方，<code>mHash</code>中数据是按升序存放，所以<code>mArray</code>的键值对数据不是按存放顺序排。</li>
<li><code>ArrayMap</code>中对应的会进行数组缓存优化，但是只针对容量为<code>4/8</code>的长度，所以如果初始化的时候用<code>4/8</code>会提高效率，但是也不一定就得用<code>4/8</code>，具体场景具体分析</li>
<li><code>ArrayMap</code>用一个变量存放无用的数组来作为缓存，并且可以重复连接来形成一个缓存链，最大缓存次数为<code>10</code></li>
<li>每次扩容的时候如果超出<code>8</code>的长度，会变成原长度的<code>1.5</code>倍</li>
<li><code>ArrayMap</code>为非线程安全类，所以代码里做了很多标记判断</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin协程学习之路【一】]]></title>
        <id>https://colaman0.github.io/kylelin/post/kotlin-xie-cheng-xue-xi-zhi-lu-yi/</id>
        <link href="https://colaman0.github.io/kylelin/post/kotlin-xie-cheng-xue-xi-zhi-lu-yi/">
        </link>
        <updated>2020-04-09T07:03:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="协程介绍">协程介绍</h3>
<blockquote>
<h5 id="本质上协程像是轻量级的线程">本质上，协程像是轻量级的线程</h5>
</blockquote>
<h5 id="在我们编程的过程中-难免会出现异步编程和一些回调函数这就很容易出现callback-hell-回调地狱-也就是说可能出现大量嵌套代码这种代码在视觉效果以及逻辑维护上都堪称地狱级代码很容易给程序员带来困扰">在我们编程的过程中 难免会出现异步编程和一些回调函数，这就很容易出现<code>callback hell 回调地狱</code> ，也就是说可能出现大量嵌套代码，这种代码在视觉效果以及逻辑维护上都堪称地狱级代码，很容易给程序员带来困扰。</h5>
<h5 id="在这之前大家可能接触比较多的是像rxjava这种用于处理异步编程的框架有各种操作符以及流式调用等特点方便进行异步编程而协程在这方面和rxjava这种框架不同协程做到了让代码看起来更直白更具有逻辑性至于怎么让代码看起来更通俗易懂可以看看接下来我在学习协程中个人的一些理解和总结">在这之前大家可能接触比较多的是像<code>Rxjava</code>这种用于处理异步编程的框架，有各种操作符以及流式调用等特点方便进行异步编程，而协程在这方面和<code>Rxjava</code>这种框架不同，协程做到了让代码看起来更直白更具有逻辑性，至于怎么让代码看起来更通俗易懂，可以看看接下来我在学习协程中个人的一些理解和总结</h5>
<hr>
<h3 id="创建协程">创建协程</h3>
<p>举两个简单的创建方法 <code>runBlocking { }</code> 以及 <code>GlobalScope.launch { }</code></p>
<h4 id="runblocking"><code>runBlocking { }</code></h4>
<blockquote>
<p><code>runBlocking</code>创建了一个协程，并且会阻塞当前线程，等待作用域也就是<code>{}</code>内的代码以及所有子协程结束，并且<code>runBlocking</code> 是有返回值的，但是由于会阻塞线程，所以用的情况不多，在这里做一个入门讲解</p>
</blockquote>
<h4 id="globalscopelaunch"><code>GlobalScope.launch { }</code></h4>
<blockquote>
<p>通过这个方法创建出来的协程是一个顶层的协程，它的生命周期跟<code>application</code>是一样的，没有返回值，也不可以取消，并且不会阻塞当前线程，这一点和<code>runBlocking { }</code> 正好相反</p>
</blockquote>
<p>通过下面一段代码让大家了解一下用法</p>
<pre><code class="language-kotlin">// 简单的输出一句Hello World
GlobalScope.launch {  
    print(&quot;Hello World&quot;)
}
</code></pre>
<hr>
<h3 id="launch和job"><code>launch</code>和<code>Job</code></h3>
<blockquote>
<p><code>launch</code>是以不阻塞的方式去启动一个新的协程，需要在协程的范围内去调用，比如上面提到<code>runBlocking</code> <code>couroutineScope</code>，并且会返回一个<code>Job</code>用来控制任务的开始取消等操作</p>
</blockquote>
<pre><code>public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; Unit
): Job {
    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    coroutine.start(start, coroutine, block)
    return coroutine
}
</code></pre>
<h4 id="上面是launch的构造方法有三个参数">上面是<code>launch</code>的构造方法，有三个参数</h4>
<ul>
<li><code>context</code>：可以传入一个调度器<code>Dispatchers</code>来控制协程启动选项，默认的参数是<code>CoroutineStart.DEFAULT</code>也就是按当前的上下文环境去启动，如果我们想在IO线程中启动，可以传入<code>Dispatchers.IO</code> 还有像<code>Dispatchers.Main</code>就是在主线程中去启动</li>
<li><code>start</code>：如果我们想去控制协程的启动时机，可以通过<code>start</code>传入一个<code>CoroutineStart</code>，默认的<code>CoroutineStart</code>是立即启动，如果想要延时启动可以传入<code>CoroutineStart.LAZY</code>, 然后在需要启动的时候调用<code>Job</code>的<code>join</code>方法</li>
<li><code>block</code>：让协程在传入的协程范围内去运行</li>
</ul>
<h4 id="构建launch的方法讲完之后就讲一下job的作用job有几个常用的方法像是join-cancel-cancelandjoin">构建<code>launch</code>的方法讲完之后就讲一下<code>Job</code>的作用，<code>Job</code>有几个常用的方法，像是<code>join</code> <code>cancel</code> <code>cancelAndJoin</code></h4>
<ul>
<li>
<p><code>join</code>：启动协程任务并且会以一个非阻塞的方式去等待这个<code>Job</code>完成</p>
</li>
<li>
<p><code>cancel</code>：取消任务</p>
</li>
<li>
<p><code>cancelAndJoin</code>：综合上面两个方法，实际上内部就是先调用了<code>cancel</code>再调用<code>join</code>,也就是说会等待协程内的任务完成之后，再继续往下执行代码，如果是<code>cancel</code>的话，那么调用的时候协程内的任务就会直接中断</p>
<blockquote>
<p>以上两种cancel，举个在安卓中的实际场景，比如一个草稿箱功能 ，用户在点击退出之后弹出一个loading框，这个时候可以用<code>cancelAndJoin</code>等待上传完成之后再dissmiss，如果用户选择直接退出，那么可以用<code>cancel</code></p>
</blockquote>
<blockquote>
<p>另外被取消的协程，会抛出一个<code>CancellationException</code>异常，表示协程被正常取消，如果你没有捕获错误的话，不会打印到控制台/日志</p>
</blockquote>
</li>
<li>
<p><code>isActive</code>：这是一个判断当前协程是否还存活的标记，可以在任务中根据这个属性决定任务是否继续</p>
</li>
</ul>
<h4 id="在协程中如果你想要在任务结束之后做一些操作那么你可以用tryfinally这样的操作把任务逻辑写在try中在finally中释放资源">在协程中如果你想要在任务结束之后做一些操作，那么你可以用<code>try{}finally{}</code>这样的操作把任务逻辑写在<code>try</code>中，在<code>finally</code>中释放资源</h4>
<hr>
<h3 id="作用域构建器">作用域构建器</h3>
<blockquote>
<p>除了由不同的构建器提供协程作用域之外，还可以使用 <code>coroutineScope</code> 构建器声明自己的作用域。它会创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束。<code>coroutineScope</code> 是非阻塞式的，是挂起函数，而<code>runBlocking</code> 是阻塞式，属于常规的函数，但是两者都会等待各自作用域中的所有子协程结束</p>
</blockquote>
<h5 id="关于上面说的runblocking-是阻塞式coroutinescope是非阻塞式可以通过下面一段代码来体现">关于上面说的<code>runBlocking { }</code>是阻塞式，<code>coroutineScope</code>是非阻塞式，可以通过下面一段代码来体现</h5>
<pre><code>import kotlinx.coroutines.*

fun main() = runBlocking { 
    // 用launch启动一个子协程
    launch { 
        delay(200L)
        println(&quot;Task from runBlocking&quot;)
    }
    
    // 创建一个协程作用域
    coroutineScope { 
        launch {
            delay(500L) 
            println(&quot;Task from nested launch&quot;)
        }
    
        delay(100L)
        println(&quot;Task from coroutine scope&quot;) // 这一行会在内嵌 launch 之前输出
    }
    
    println(&quot;Coroutine scope is over&quot;) // 这一行在内嵌 launch 执行完毕后才输出
}


最终的输出结果：x
Task from coroutine scope 
Task from runBlocking 
Task from nested launch 
Coroutine scope is over

</code></pre>
<h5 id="这一段代码取自kotlin官方文档用来说明runblocking-和coroutinescope的阻塞以及非阻塞式区别有的人可能会觉得有点疑惑代码上看起来coroutinescope后面的打印总是会在最后才输出看起来似乎coroutinescope才是阻塞式的br-然而并不是这样task-from-runblocking这一段先打印相信大家可以明白接着代码运行到了coroutinescope作用域里作用域中有子协程相信大家也能明白作用域中打印的顺序那么问题来了为什么coroutine-scope-is-over总是在最后打印-br-其实是因为上面所提到的阻塞和非阻塞式特点coroutinescope作用域会以非阻塞式的等待所有子协程完成所以内部第一个launch在运行到delay的时候并没有阻塞住线程而是继续运行下去所以会先打印延时比较短的task-from-coroutine-scope之后delay时间到了协程切回去打印了task-from-nested-launch而由于coroutinescope是在runblocking-当中所以当couroutinescope没有结束之前runblocking会阻塞当前线程等待所以在coroutinescope内部delay没有结束没有打印完成之前最后一句println并不会被执行到"> 这一段代码取自kotlin官方文档，用来说明<code>runBlocking { }</code>和<code>coroutineScope</code>的阻塞以及非阻塞式区别，有的人可能会觉得有点疑惑，代码上看起来<code>coroutineScope</code>后面的打印总是会在最后才输出，看起来似乎<code>coroutineScope</code>才是阻塞式的<br> 然而并不是这样，<code>Task from runBlocking</code>这一段先打印相信大家可以明白，接着代码运行到了<code>coroutineScope</code>作用域里，作用域中有子协程，相信大家也能明白作用域中打印的顺序，那么问题来了，为什么<code>Coroutine scope is over</code>总是在最后打印。<br> 其实是因为上面所提到的阻塞和非阻塞式特点，<code>coroutineScope</code>作用域会以非阻塞式的等待所有子协程完成，所以内部第一个<code>launch</code>在运行到<code>delay</code>的时候并没有阻塞住线程，而是继续运行下去，所以会先打印延时比较短的<code>Task from coroutine scope</code>，之后<code>delay</code>时间到了协程切回去打印了<code>Task from nested launch</code>，而由于<code>coroutineScope</code>是在<code>runBlocking</code> 当中，所以当<code>couroutineScope</code>没有结束之前，<code>runBlocking</code>会阻塞当前线程等待，所以在<code>coroutineScope</code>内部<code>delay</code>没有结束，没有打印完成之前，最后一句<code>println</code>并不会被执行到。</h5>
<hr>
<h3 id="这篇文章就暂时讲这么多知识点接下来我也会根据自己在学习协程过程的一些疑惑以及总结陆续写后续的相关文章">这篇文章就暂时讲这么多知识点，接下来我也会根据自己在学习协程过程的一些疑惑以及总结陆续写后续的相关文章</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内存优化相关]]></title>
        <id>https://colaman0.github.io/kylelin/post/nei-cun-you-hua-xiang-guan/</id>
        <link href="https://colaman0.github.io/kylelin/post/nei-cun-you-hua-xiang-guan/">
        </link>
        <updated>2020-04-09T07:03:17.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="总结一些比较日常的内存优化策略">总结一些比较日常的内存优化策略</h4>
]]></summary>
        <content type="html"><![CDATA[<h4 id="总结一些比较日常的内存优化策略">总结一些比较日常的内存优化策略</h4>
<!-- more -->
<ul>
<li>
<h4 id="用sparsearray-arraymap-代替hashmap">用SparseArray / ArrayMap 代替HashMap</h4>
</li>
</ul>
<h5 id="sparsearray">SparseArray:</h5>
<blockquote>
<p>如果key的类型已经确定为int类型，那么使用SparseArray，因为它避免了自动装箱的过程，如果key为long类型，它还提供了一个<code>LongSparseArray</code>来确保key为long类型时的使用，如果key类型为其它的类型，则使用<code>ArrayMap</code></p>
</blockquote>
<h5 id="arraymap">ArrayMap:</h5>
<blockquote>
<p>android.util.ArrayMap存储结构是由int[] mHashes和Object[] mArray两个数据组成，mHashes保存key的hashCode，mArray以键值对形式保存key和value。 ArrayMap取数据时通过二分法查找index，获取相应value。 ArrayMap在remove和clear后，会重新收缩数据，节约空间，但会降低执行效率。ArrayMap是牺牲了时间换取空间。根据官方描述，由于查找方式采用的是二分法，并且当你删除或者添加数据时，会对空间重新调整，ArrayMap不太适合数据量比较大的场景。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f682856d23d7?w=487&amp;h=406&amp;f=png&amp;s=88544" alt="image.png" loading="lazy"></figure>
<ul>
<li>
<h4 id="enum-枚举">Enum (枚举)</h4>
</li>
</ul>
<p>避免使用枚举，用静态变量代替，枚举占用的内容大的多</p>
<ul>
<li>
<h4 id="减少-bitmap-对象的内存占用">减少 Bitmap 对象的内存占用</h4>
</li>
</ul>
<blockquote>
<p>Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用是很重要的，通常来说有下面2个措施：</p>
</blockquote>
<h5 id="1insamplesize缩放比例在把图片载入内存之前我们需要先计算出一个合适的缩放比例避免不必要的大图载入">1.inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。</h5>
<h5 id="2decode-format解码格式选择-argb_8888-rbg_565-argb_4444-alpha_8这几种格式存在很大差异和内存占用情况">2.decode format：解码格式，选择 ARGB_8888 / RBG_565/ ARGB_4444 / ALPHA_8,这几种格式存在很大差异和内存占用情况。</h5>
<ul>
<li>
<h4 id="注意临时-bitmap-对象的及时回收">注意临时 Bitmap 对象的及时回收</h4>
</li>
</ul>
<blockquote>
<p>我们会对 Bitmap 增加缓存机制，但是在某些时候，部分 Bitmap 是需要及时回收的。例如临时创建的某个相对比较大的 Bitmap 对象，在经过变换得到新的 Bitmap 对象之后，应该尽快回收原始的 Bitmap，这样能够更快释放原始 Bitmap 所占用的空间。<br>
需要特别留意的是 Bitmap 类里面提供的 <code>createBitmap()</code> 方法：<br>
这个函数返回的 Bitmap 有可能和 source bitmap 是同一个，在回收的时候，需要特别检查 source bitmap 与 return bitmap 的引用是否相同，只有在不等的情况下，才能够执行 source bitmap 的 recycle() 方法</p>
</blockquote>
<ul>
<li>
<h4 id="尽量地采用-int-类型">尽量地采用 int 类型</h4>
</li>
</ul>
<blockquote>
<p>Android 系统中 float 类型的数据存取速度是 int 类型的一半，尽量优先采用 int 类型。而同样能作为整数的代名词，采用 int 替换 Integer 会让你的内存开销更小。</p>
</blockquote>
<ul>
<li>适当使用intern</li>
</ul>
<blockquote>
<p>JDK7以及以后String类提供了<code>intern()</code>方法，手动调用可以把对象放到常量池中，后续调用的时候如果在常量池中匹配到了就直接使用，避免重复创建对象，但是使用了<code>intern()</code> 之后会相当于花费多一点点时间，但是数据多的情况下，花费的那点时间和节省下来的空间来说还是不值一提的</p>
</blockquote>
<ul>
<li>
<h4 id="尽量使用原字符串的-substring">尽量使用原字符串的 subString</h4>
</li>
</ul>
<blockquote>
<p>当从已经存在的数据集中抽取出 String 的时候，尝试返回原数据的<code>subString</code> 对象，而不要创建一个重复的对象。这一点比较少见，因为每次调用<code>subString</code>方法都会创建一个新的String对象</p>
</blockquote>
<ul>
<li>
<h4 id="避免在频繁调用的方法比如-ondraw-里面执行对象的创建">避免在频繁调用的方法比如 onDraw() 里面执行对象的创建</h4>
</li>
</ul>
<blockquote>
<p>类似 onDraw() 等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的 gc，甚至是内存抖动。</p>
</blockquote>
<ul>
<li>
<h4 id="循环里操作字符串的时候改用stringbufferstringbuilder来操作">循环里操作字符串的时候改用<code>StringBuffer</code>/<code>StringBuilder</code>来操作</h4>
</li>
</ul>
<blockquote>
<p>如果直接在循环里用 <code>+</code> 拼接字符串，会创建很多无用的对象，比如说以下代码在每次循环的时候都会创建了新的<code>StringBuilder</code>对象，所以这种情况可以在外部创建一个<code>StringBuilder</code>对象，在循环内调用<code>append</code>方法</p>
</blockquote>
<pre><code>for(int i = 0; i &lt; 100; i++) {  
    s += &quot;a&quot;;    
}   
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Handler机制解析]]></title>
        <id>https://colaman0.github.io/kylelin/post/handler-ji-zhi-jie-xi/</id>
        <link href="https://colaman0.github.io/kylelin/post/handler-ji-zhi-jie-xi/">
        </link>
        <updated>2020-04-09T07:02:58.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="分析一下handler源码以及一些核心部分的代码">分析一下Handler源码以及一些核心部分的代码</h4>
]]></summary>
        <content type="html"><![CDATA[<h4 id="分析一下handler源码以及一些核心部分的代码">分析一下Handler源码以及一些核心部分的代码</h4>
<!-- more -->
<h3 id="handler-原理">Handler 原理：</h3>
<h5 id="首先sendmessage以及-sendmessagedelayed最后调用的都是-sendmessagedelayed接着开始总体流程">首先sendMessage（）以及 sendMessageDelayed()最后调用的都是 sendMessageDelayed()，接着开始总体流程</h5>
<blockquote>
<h5 id="遍历链表-首先判断链表里有没有message如果里面是空的或者传入的msg执行的时间比头message要早则把msg放到链表的头部-比如send两次message先执行的有延时后执行的没延时这个时候就要把后执行的message放到最前面-接着遍历链表根据执行的事件去调整message的位置">遍历链表： 首先判断链表里有没有message，如果里面是空的或者传入的msg执行的时间比头message要早，则把msg放到链表的头部，（ 比如send两次message，先执行的有延时，后执行的没延时，这个时候就要把后执行的message放到最前面） 接着遍历链表，根据执行的事件去调整message的位置：</h5>
</blockquote>
<h4 id="第一次添加数据到队列中或者当前-msg-的时间小于-mmessages-的时间">第一次添加数据到队列中，或者当前 msg 的时间小于 mMessages 的时间</h4>
<pre><code>// p为队列中头部msg
if (p == null || when == 0 || when &lt; p.when) {

        // New head, wake up the event queue if blocked.

        // 把当前 msg 添加到链表的第一个

        msg.next = p;

        mMessages = msg;

        needWake = mBlocked;

} else {

        // 不是第一次添加数据，并且 msg 的时间 大于 mMessages(头指针) 的时间

        // Inserted within the middle of the queue.  Usually we don't have to wake

        // up the event queue unless there is a barrier at the head of the queue

        // and the message is the earliest asynchronous message in the queue.

        needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();

        Message prev;

        for (;;) {

        // 不断的遍历找到合适的位置

        prev = p;

        p = p.next;

        if (p == null || when &lt; p.when) {     // 根据执行时间判断应该插到哪个位置    

        break;

        }

        if (needWake &amp;&amp; p.isAsynchronous()) {

        needWake = false;

        }

        }

        // 把当前 msg 插入到列表中

        msg.next = p; // invariant: p == prev.next

        prev.next = msg;

}

</code></pre>
<h3 id="looper">Looper</h3>
<blockquote>
<h5 id="looper是通过不断循环去获取message的要使用handler子线程中必须调用looperprepare以及-looperloop-主线程中默认有一个looperactivitythread中系统已经初始化了一个looper下面是具体逻辑代码">Looper是通过不断循环去获取message的，要使用handler，子线程中必须调用looper.prepare()以及 looper.loop()。主线程中默认有一个looper，ActivityThread中系统已经初始化了一个looper，下面是具体逻辑代码</h5>
</blockquote>
<pre><code>public static void loop() {

    final Looper me = myLooper();

    final MessageQueue queue = me.mQueue;

    // 一个死循环

    for (;;) {

        // 不断的从消息队列里面取消息

        Message msg = queue.next(); // might block

        if (msg == null) {

            // No message indicates that the message queue is quitting.

            return;

        }

        try {

            // 通过 target 去 dispatchMessage 而 target 就是绑定的 Handler
            // 到这里也就完成了消息的传递流程

            msg.target.dispatchMessage(msg);

        } finally {

            // 消息回收循环利用

            msg.recycleUnchecked();

        }

    }

}
</code></pre>
<h4 id="在这里loop的死循环涉及到pipe知识就不深入探讨如下图">在这里loop的死循环涉及到pipe知识就不深入探讨，如下图</h4>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f67c46c3a208?w=1024&amp;h=592&amp;f=jpeg&amp;s=41745" alt="image.gif" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f67c46d2b8e4?w=1061&amp;h=211&amp;f=png&amp;s=83002" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RecyclerView源码解析]]></title>
        <id>https://colaman0.github.io/kylelin/post/recyclerview-yuan-ma-jie-xi/</id>
        <link href="https://colaman0.github.io/kylelin/post/recyclerview-yuan-ma-jie-xi/">
        </link>
        <updated>2020-04-09T07:02:43.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="作为一个很重要的viewrecyclerview内部实现也是很复杂的下面简单概括以及总结一下一些比较重要的方法以及实现的思路">作为一个很重要的view，recyclerview内部实现也是很复杂的，下面简单概括以及总结一下一些比较重要的方法以及实现的思路</h4>
]]></summary>
        <content type="html"><![CDATA[<h4 id="作为一个很重要的viewrecyclerview内部实现也是很复杂的下面简单概括以及总结一下一些比较重要的方法以及实现的思路">作为一个很重要的view，recyclerview内部实现也是很复杂的，下面简单概括以及总结一下一些比较重要的方法以及实现的思路</h4>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f67321972959?w=960&amp;h=960&amp;f=png&amp;s=458638" alt="image.png" loading="lazy"></figure>
<h3 id="关键性几个方法以及变量">关键性几个方法以及变量</h3>
<ul>
<li>dispatchLayoutStep1</li>
<li>dispatchLayoutStep2</li>
<li>dispatchLayoutStep3</li>
<li>ViewInfoStore</li>
<li>ViewInfoStore.ProcessCallback</li>
</ul>
<h4 id="dispatchlayoutstep1">dispatchLayoutStep1</h4>
<blockquote>
<p>第一步负责把旧的viewholder的信息记录下来，包括position，top，left等位置的信息，封装成<code>ItemHolderInfo</code><br>
作为一个成员放置到<code>ViewInfoStore.InfoRecord</code>中的<code>preInfo</code>变量然后放到<code>ViewInfoStore</code>中，<br>
具体可以查看 <code>addToAppearedInPreLayoutHolders</code>/<code>addToPreLayout</code>方法</p>
</blockquote>
<h4 id="dispatchlayoutstep2">dispatchLayoutStep2</h4>
<blockquote>
<p>第二步负责view的布局，这一步由<code>layoutmanager</code>来处理，比如设置的<code>LinearlayoutManager</code>等</p>
</blockquote>
<h4 id="dispatchlayoutstep3">dispatchLayoutStep3</h4>
<blockquote>
<p>第三步负责动画的显示，先是把布局过后的view的信息记录下来，调用了<code>addToPostLayout</code>方法，封装成<code>ItemHolderInfo</code><br>
作为一个成员放置到<code>ViewInfoStore.InfoRecord</code>中然后放到<code>ViewInfoStore</code>中，这里的是记录在了<code>InfoRecord</code>的<code>postInfo</code>中去,最后调用<code>this.mViewInfoStore.process(this.mViewInfoProcessCallback);</code> 去开始对view进行动画操作</p>
</blockquote>
<h5 id="这里step1和step3中分别用一个itemholderinfo记录了布局前后view的信息然后放在了inforecord中的preinfo以及postinfo中这样一个inforecord就可以记录一个holder在布局改变前后的位置信息方便后续做动画上的变化">这里step1和step3中分别用一个ItemHolderInfo记录了布局前后view的信息，然后放在了<code>InfoRecord</code>中的<code>preInfo</code>以及<code>postInfo</code>中，这样一个<code>InfoRecord</code>就可以记录一个holder在布局改变前后的位置信息，方便后续做动画上的变化</h5>
<h4 id="onmeasure">OnMeasure</h4>
<blockquote>
<p>这里的测量分两种方式,recyclerview有默认的测量策略，layoutmanager可以通过关闭autoMeasure来接管测量的逻辑，但是一般的都是使用默认的测量，</p>
</blockquote>
<pre><code> int widthMode = MeasureSpec.getMode(widthSpec);
                int heightMode = MeasureSpec.getMode(heightSpec);
                this.mLayout.onMeasure(this.mRecycler, this.mState, widthSpec, heightSpec);
                boolean measureSpecModeIsExactly = widthMode == 1073741824 &amp;&amp; heightMode == 1073741824;
                // 表明如果recyclerview有一个确切的宽高，就直接结束流程，否则就要开始下面的逻辑
                if (measureSpecModeIsExactly || this.mAdapter == null) {
                    return;
                }
                // 如果recyclerview是wrapcontent，宽高无法确定，就需要先去排列view，计算出高度再去设置
                // 这里的state记录了当前layout进行到了第几步，详细可以看下面的介绍
                if (this.mState.mLayoutStep == 1) {
                    this.dispatchLayoutStep1();
                }

                this.mLayout.setMeasureSpecs(widthSpec, heightSpec);
                this.mState.mIsMeasuring = true;
                this.dispatchLayoutStep2();
                this.mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);
                if (this.mLayout.shouldMeasureTwice()) {
                    this.mLayout.setMeasureSpecs(MeasureSpec.makeMeasureSpec(this.getMeasuredWidth(), 1073741824), MeasureSpec.makeMeasureSpec(this.getMeasuredHeight(), 1073741824));
                    this.mState.mIsMeasuring = true;
                    this.dispatchLayoutStep2();
                    this.mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);
                }
</code></pre>
<h5 id="recyclerviewstate-这个类封装了当前recyclerview的有用信息-state的一个变量mlayoutstep表示了recyclerview当前的布局状态包括step_start-step_layout-step_animations三个而recyclerview的布局过程也分为三步其中step_start表示即将开始布局需要调用dispatchlayoutstep1来执行第一步布局接下来布局状态变为step_layout表示接下来需要调用dispatchlayoutstep2里进行第二步布局同理第二步布局后状态变为step_animations需要执行第三步布局dispatchlayoutstep3-所以onmeasure如果已经进行了第12步后续dispatchlayout方法里只会执行第三步避免重复测量"><code>RecyclerView.State</code> 这个类封装了当前RecyclerView的有用信息。State的一个变量mLayoutStep表示了RecyclerView当前的布局状态，包括<code>STEP_START</code>、<code>STEP_LAYOUT</code> 、 <code>STEP_ANIMATION</code>S三个，而RecyclerView的布局过程也分为三步，其中，<code>STEP_START</code>表示即将开始布局，需要调用<code>dispatchLayoutStep1</code>来执行第一步布局，接下来，布局状态变为<code>STEP_LAYOUT</code>，表示接下来需要调用<code>dispatchLayoutStep2</code>里进行第二步布局，同理，第二步布局后状态变为<code>STEP_ANIMATIONS</code>，需要执行第三步布局<code>dispatchLayoutStep3</code>。所以<code>OnMeasure</code>如果已经进行了第1，2步，后续<code>dispatchLayout</code>方法里只会执行第三步，避免重复测量</h5>
<hr>
<h4 id="adapter">Adapter</h4>
<ul>
<li>AdapterDataObserver</li>
<li>AdapterDataObservable</li>
</ul>
<p>adapter中的数据刷新是通过观察者模式来触发的，adapter内有一个<code>AdapterDataObservable</code>对象，当我们调用adapter的noti类方法通知recyclerview刷新的时候，<code>AdapterDataObservable</code>会通知观察者也就是<code>AdapterDataObserver</code> ，而<code>AdapterDataObserver</code>对象在recyclerview 里有一个实例化对象<code>RecyclerViewDataObserver</code>可以查看内部代码，这里的代码就是最后去刷新的逻辑</p>
<h5 id="1调用adapterhelper中的具体方法去判断是否执行刷新操作方法内会记录当前操作类型是addmovechange还有itemvcount等信息一般返回true如果是notifydatasetchanged就直接执行到requestlayout-跳到第7点">1.调用<code>Adapterhelper</code>中的具体方法去判断是否执行刷新操作，方法内会记录当前操作类型是add/move/change还有itemvcount等信息，一般返回true,如果是<code>notifyDataSetChanged</code>就直接执行到<code>requestLayout</code> 跳到第<code>7</code>点</h5>
<h5 id="2triggerupdateprocessor">2.<code>triggerUpdateProcessor</code></h5>
<h5 id="3-执行mupdatechildviewsrunnable这个runnable">3. 执行<code>mUpdateChildViewsRunnable</code>这个runnable</h5>
<h5 id="4-consumependingupdateoperations">4. <code>consumePendingUpdateOperations</code></h5>
<h5 id="5-adapterhelper的preprocess去判断要add还是remove等操作">5. <code>AdapterHelper</code>的<code>preProcess</code>去判断要add还是remove等操作</h5>
<h5 id="6-调用adapterhelper的preprocess去回调到recyclerview中的对应的方法然后调用offsetpositionsforadd等方法去确认变换过后的viewhodler的位置信息比如add-remove-之后其他item的坐标等同时把cachedview也做同样的操作">6. 调用<code>AdapterHelper</code>的<code>preProcess</code>去回调到<code>recyclerview</code>中的对应的方法，然后调用<code>offsetPositionsForAdd</code>等方法，去确认变换过后的<code>viewhodler</code>的位置信息，比如add remove 之后其他item的坐标等，同时把<code>cachedview</code>也做同样的操作</h5>
<h5 id="7-调用dispathchlayout方法走一遍测绘流程就是一开始说的三步这个时候新旧viewholder的信息被分别记录起来最后调用thismviewinfostoreprocessthismviewinfoprocesscallback">7. 调用<code>dispathchLayout</code>方法，走一遍测绘流程，就是一开始说的三步，这个时候新旧viewholder的信息被分别记录起来,最后调用<code>this.mViewInfoStore.process(this.mViewInfoProcessCallback);</code></h5>
<h5 id="8-在这里面根据viewholder前后信息去判断具体每个view是添加删除还是移动等操作回调到recyclerview里的mviewinfoprocesscallback也就是上面的callback然后run一个runnable让recyclerview的itemanimator对象调用runpendinganimations去开始对view进行动画操作具体可以查看defaultitemanimator里的实现">8. 在这里面根据viewholder前后信息，去判断具体每个view是添加删除还是移动等操作，回调到recyclerview里的<code>mViewInfoProcessCallback</code>也就是上面的callback，然后run一个runnable，让recyclerview的<code>ItemAnimator</code>对象调用<code>runPendingAnimations</code>去开始对view进行动画操作，具体可以查看<code>DefaultItemAnimator</code>里的实现</h5>
<h4 id="notifydatasetchanged">notifyDataSetChanged</h4>
<blockquote>
<p>notifyDataSetChanged会调用<code>processDataSetCompletelyChanged</code>，方法里把<code>mDataSetHasChangedAfterLayout</code>设为了true，后续在step1里<code>processAdapterUpdatesAndSetAnimationFlags</code>判断把<code>mRunSimpleAnimations</code>和<code>mRunPredictiveAnimations</code>射程了<code>false</code>，所以就跳过了记录<code>旧holder</code>这一步，所以调用的时候没有完整的动画</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f67321957ece?w=1090&amp;h=719&amp;f=png&amp;s=120457" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f67321bd289a?w=1045&amp;h=348&amp;f=png&amp;s=54199" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f67321bbc76a?w=1240&amp;h=408&amp;f=png&amp;s=201599" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rxjava2解析-订阅流程]]></title>
        <id>https://colaman0.github.io/kylelin/post/rxjava2-jie-xi-ding-yue-liu-cheng/</id>
        <link href="https://colaman0.github.io/kylelin/post/rxjava2-jie-xi-ding-yue-liu-cheng/">
        </link>
        <updated>2020-04-09T07:02:28.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="总结一下rxjava一个最基本的订阅流程是如何实现的以及rxjava的设计思路是什么样的">总结一下Rxjava一个最基本的订阅流程是如何实现的，以及Rxjava的设计思路是什么样的</h4>
]]></summary>
        <content type="html"><![CDATA[<h4 id="总结一下rxjava一个最基本的订阅流程是如何实现的以及rxjava的设计思路是什么样的">总结一下Rxjava一个最基本的订阅流程是如何实现的，以及Rxjava的设计思路是什么样的</h4>
<!-- more -->
<h4 id="订阅">订阅</h4>
<p>首先创建一个<code>observer</code>和<code>observable</code></p>
<pre><code>new Observer&lt;Object&gt;() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onNext(Object o) {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onComplete() {

            }
        };
</code></pre>
<pre><code> Observable.create(new ObservableOnSubscribe&lt;Object&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Object&gt; emitter) throws Exception {

            }
        });
</code></pre>
<ul>
<li>
<h4 id="先看observable的创建过程create只是把传进去observableonsubscribe对象包装了一层返回这里可以忽略">先看<code>Observable</code>的创建过程，<code>create()</code>只是把传进去<code>ObservableOnSubscribe</code>对象包装了一层返回,这里可以忽略</h4>
</li>
<li>
<h4 id="然后是observableonsubscribe类的内部">然后是<code>ObservableOnSubscribe</code>类的内部</h4>
</li>
</ul>
<pre><code>    final ObservableOnSubscribe&lt;T&gt; source;

    public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) {
        // 1
        this.source = source;
    }

    @Override
    protected void subscribeActual(Observer&lt;? super T&gt; observer) {
        // 2
        CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);
        observer.onSubscribe(parent);

        try {
        // 3 
            source.subscribe(parent);
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            parent.onError(ex);
        }
    }
</code></pre>
<h5 id="1-在这里把传进来的observableonsubscribe对象保存起来">1. 在这里把传进来的ObservableOnSubscribe对象保存起来</h5>
<h5 id="2-这里new了一个emitter也就是我们用来onnextonerror的类然后把emitter传给observer中由于createemitter实现了disposable接口所以可以看到observer里有一个onsubscribedisposable-d我们可以用来控制流的结束等操作实际上这个disposable就是源obserable创建的">2. 这里new了一个Emitter，也就是我们用来onNext,onError的类,然后把Emitter传给observer中，由于CreateEmitter实现了Disposable接口，所以可以看到Observer里有一个<code>onSubscribe(Disposable d)</code>，我们可以用来控制流的结束等操作，实际上这个<code>Disposable</code>就是源Obserable创建的，</h5>
<h5 id="3-这里把emitter传给source也就是传给我们new的observableonsubscribe的subscribe">3. 这里把<code>Emitter</code>传给source，也就是传给我们new的<code>ObservableOnSubscribe</code>的<code>subscribe()</code></h5>
<h4 id="到这里可以看出最简单的一个订阅流程是什么样的">到这里可以看出最简单的一个订阅流程是什么样的</h4>
<h3 id="变化操作">变化操作</h3>
<ul>
<li>以map操作来看，map变化返回了一个<code>ObservableMap</code> ,也是一个<code>Observable</code></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f66de59a2797?w=852&amp;h=176&amp;f=png&amp;s=42741" alt="image.png" loading="lazy"></figure>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f66de5718655?w=1240&amp;h=830&amp;f=png&amp;s=211807" alt="image.png" loading="lazy"><br>
<img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f66de589576c?w=1240&amp;h=559&amp;f=png&amp;s=207727" alt="image.png" loading="lazy"></p>
<ul>
<li>这里其实可以看出，每一个<code>Observable</code> 都会有一个<code>subscribeActual()</code>方法，这个方法在<code>Observable</code>调用<code>subscrible()</code>之后会被调用，也就是说一个<code>Observable</code>在调用<code>subscrible()</code>之后，实际上的操作逻辑都是在<code>subscribeActual()</code>里面</li>
<li>在<code>ObservableMap</code>的<code>subscribeActual()</code>里，调用了<code>source.subscribe(new MapObserver&lt;T, U&gt;(t, function));</code> 这句代码，<code>source</code>是上层的observable，参数为包装过后的<code>observer</code>即<code>MapObserver</code>,由图三可以看出，<code>MapObserver</code>内部的<code>onNext</code>是往下游传递一个经过<code>apply()</code>变化过后的数据，也就达到了我们用<code>map</code>变化数据的功能了。</li>
</ul>
<h3 id="结论">结论</h3>
<ul>
<li><code>Observable</code>只有在调用了<code>subscribed()</code>订阅了<code>observer</code>之后才会开始整个流程，调用了<code>subscribed()</code>之后会调用到<code>subscribeActual(Observer&lt;? super U&gt; t)</code> 实际上就是把<code>observer</code>从最下游，往上面传递。<br>
而在<code>subscribeActual(Observer&lt;? super U&gt; t)</code>这个方法内，会调用<code>source.subscribe(Observer);</code>也就是说最下游开始订阅之后，中间的每一个<code>Observable</code>都会调用到<code>subscribeActual</code>方法，然后调用<code>source</code>也就是上一个Observable的<code>subscribe</code>方法，这样就做到了把observer往上传。然后<code>downstream</code>保存下游的Observable，这样子做是为了上游传递数据的时候，自己先经过变化，然后再把数据给传递到下游<br>
中间具体把<code>observer</code>包装的逻辑都在各自<code>Observable</code>的<code>subscribeActual</code>中去做，比如<code>map</code>变化，就是把observer包装成<code>MapObserver</code>然后传递到上游.然后<code>源Observable</code>发射数据的时候就调用各自的方法去变换数据，再传递下去<br>
也就是说中间各种变化，实际都是把observer给包装起来，传递到<code>源Observable</code>中去，然后<code>源Observble</code>发射数据了，就一层层的包装变换然后传递下去</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f66de5c3e6a1?w=1240&amp;h=830&amp;f=png&amp;s=211811" alt="image.png" loading="lazy"></figure>
<ul>
<li><code>onSubscribe()</code>是在源Observable创建好emitter发射器之后，会调用observer的<code>onSubscribe()</code>方法，中间如果有变换的话，由于变化产生的Observable会把下游的observer包装传给上游，同时自己也保存了下游包装过后的的observer,所以会一层层的调用下游包装过的observer的onSubscribe方法，直到最后的源observer<br>
<img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f66de5bc4c53?w=784&amp;h=807&amp;f=png&amp;s=49809" alt="image.png" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rxjava2-线程切换解析]]></title>
        <id>https://colaman0.github.io/kylelin/post/rxjava2-xian-cheng-qie-huan-jie-xi/</id>
        <link href="https://colaman0.github.io/kylelin/post/rxjava2-xian-cheng-qie-huan-jie-xi/">
        </link>
        <updated>2020-04-09T07:02:02.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="这篇文章来总结一下rxjava中切换线程的内在是怎么实现的">这篇文章来总结一下Rxjava中切换线程的内在是怎么实现的</h4>
]]></summary>
        <content type="html"><![CDATA[<h4 id="这篇文章来总结一下rxjava中切换线程的内在是怎么实现的">这篇文章来总结一下Rxjava中切换线程的内在是怎么实现的</h4>
<!-- more -->
<h3 id="observableon">ObservableOn()</h3>
<h5 id="直接查看实现会发现onsubscribe中做了一些判断比如82-104等几行都是做了一些同步-异步-等的判断然后初始化disposableonsubscribe是上游observable完成了整条订阅链之后调用的所以这些操作是在开始订阅之后才初始化操作然后106行可以看出把一个包装处理过的disposable传递给下游">直接查看实现，会发现<code>onSubscribe()</code>中做了一些判断，比如<code>82</code> <code>104</code>等几行都是做了一些<code>同步</code> <code>异步</code> 等的判断，然后初始化<code>Disposable</code>，<code>onSubscribe()</code>是上游<code>Observable</code>完成了整条订阅链之后调用的，所以这些操作是在开始订阅之后才初始化操作，然后<code>106</code>行可以看出把一个包装处理过的<code>Disposable</code>传递给下游</h5>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f6660af93527?w=1127&amp;h=823&amp;f=png&amp;s=131893" alt="image.png" loading="lazy"></figure>
<hr>
<h5 id="和之前的一样subscribeactual方法里会将observer进行包装然后传递给source也就是上游进行订阅">和之前的一样，<code>subscribeActual</code>方法里会将<code>observer</code>进行包装，然后传递给source也就是上游进行订阅</h5>
<pre><code>* `40`行进行了判断所传进来的`scheduler`是否跟原本的线程一致，如果是一样的就直接传递不用进行处理
*  `43`行创建了一个对应`scheduler`的`worker`，`worker`在后续负责把数据在对应的线程进行发射操作
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f6660b1e4f76?w=1034&amp;h=314&amp;f=png&amp;s=51418" alt="image.png" loading="lazy"></figure>
<h5 id="发射数据onnext处理">发射数据<code>onNext</code>处理</h5>
<pre><code>        @Override
        public void onNext(T t) {
          ...
          // 前面的都先忽略掉，会发现最后会调用这个方法
            schedule();
        }
        
      void schedule() {
         if (getAndIncrement() == 0) {
         // 在这个可以看到，上面根据schedule的worker执行了schedule(),并且把自身传进去，this其实实现了runnable，所以可以理解为传了一个runnable进去
            worker.schedule(this);
        }
    }
</code></pre>
<h5 id="接着上面的以androidschedulersmainthread这个scheduler为例这里实际上是将主线程的looper传进去了">接着上面的以<code>AndroidSchedulers.mainThread()</code>这个scheduler为例,这里实际上是将主线程的<code>looper</code>传进去了</h5>
<figure data-type="image" tabindex="3"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f6660b4b4fa8?w=953&amp;h=426&amp;f=png&amp;s=80752" alt="image.png" loading="lazy"></figure>
<h4 id="查看一下这个scheduler的worker会发现worker的基类schedule方法是相同的互相调用的所以可以直接看多个参数的schedule可以看到73行创建了一个scheduledrunnable对象并且把主线程的handler以及外面的observer传递过去接着82行用主线程的handler发送消息119行scheduledrunnable里的run被调用接着observer也就是runnable也调用run方法">查看一下这个scheduler的worker，会发现worker的基类schedule()方法是相同的互相调用的，所以可以直接看多个参数的schedule(),可以看到<code>73</code>行创建了一个<code>ScheduledRunnable</code>对象，并且把<code>主线程的handler</code>以及外面的<code>Observer</code>传递过去，接着<code>82</code>行用主线程的handler发送消息，<code>119</code>行<code>ScheduledRunnable</code>里的<code>run</code>被调用，接着<code>Observer也就是runnable</code>也调用<code>run</code>方法</h4>
<figure data-type="image" tabindex="4"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f6660bef47f9?w=1084&amp;h=827&amp;f=png&amp;s=139399" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f66610d466fc?w=929&amp;h=759&amp;f=png&amp;s=90246" alt="image.png" loading="lazy"></figure>
<h5 id="到这里可以看出实际上当切换线程的时候observer也实现了runnable的onnext往scheduler里发送自身让scheduler来决定自身应该在什么线程执行run方法接下来看回observer的run方法就是判断了一下要执行哪个方法">到这里可以看出，实际上当切换线程的时候，observer(<code>也实现了Runnable</code>)的onNext往scheduler里发送自身，让scheduler来决定自身应该在什么线程执行run方法,接下来看回observer的run方法，就是判断了一下要执行哪个方法</h5>
<figure data-type="image" tabindex="6"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f666125d472b?w=500&amp;h=215&amp;f=png&amp;s=23340" alt="image.png" loading="lazy"></figure>
<h5 id="可以看到最后是调用了onnext方法到这里就完成了指定线程发射数据的功能">可以看到最后是调用了onNext方法，到这里就完成了指定线程发射数据的功能</h5>
<pre><code>        void drainNormal() {
            int missed = 1;

            final SimpleQueue&lt;T&gt; q = queue;
            final Observer&lt;? super T&gt; a = downstream;

            for (;;) {
                if (checkTerminated(done, q.isEmpty(), a)) {
                    return;
                }

                for (;;) {
                    boolean d = done;
                    T v;

                    try {
                        v = q.poll();
                    } catch (Throwable ex) {
                        Exceptions.throwIfFatal(ex);
                        disposed = true;
                        upstream.dispose();
                        q.clear();
                        a.onError(ex);
                        worker.dispose();
                        return;
                    }
                    boolean empty = v == null;

                    if (checkTerminated(d, empty, a)) {
                        return;
                    }

                    if (empty) {
                        break;
                    }

                    a.onNext(v);
                }

                missed = addAndGet(-missed);
                if (missed == 0) {
                    break;
                }
            }
        }

</code></pre>
<h5 id="值得注意的是可以看到的是v也就是我们要发射的数据是通过poll方法获取的查看代码可以发现">值得注意的是可以看到的是<code>v</code>也就是我们要发射的数据，是通过<code>poll</code>方法获取的，查看代码可以发现</h5>
<p><code>queue</code>实际上就是一个<code>Disposable</code>也就是说是上游<code>Observable</code>,通过上游的poll方法去获取要onNext的数据</p>
<figure data-type="image" tabindex="7"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f6664a5e3555?w=1095&amp;h=802&amp;f=png&amp;s=131096" alt="image.png" loading="lazy"></figure>
<h5 id="查看observable其中一个实现observablemap的poll方法可以看到这里实际上也是调用上游的poll方法并且对数据的格式也就是不允许为null做了一层判断">查看<code>Observable</code>其中一个实现<code>ObservableMap</code>的poll方法，可以看到这里实际上也是调用上游的poll方法，并且对数据的格式也就是不允许为null做了一层判断</h5>
<pre><code>        public U poll() throws Exception {
            T t = qd.poll();
            return t != null ? ObjectHelper.&lt;U&gt;requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;) : null;
        }
</code></pre>
<h6 id="poll方法操作的对象实际上是下图104行的时候new出来的具体查看其实就是缓存数据类似一个容量池的作用">poll方法操作的对象实际上是下图<code>104</code>行的时候new出来的，具体查看其实就是缓存数据，类似一个容量池的作用</h6>
<figure data-type="image" tabindex="8"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f6664aab0da8?w=1126&amp;h=818&amp;f=jpeg&amp;s=57234" alt="image.png" loading="lazy"></figure>
<h5 id="用一段伪代码来展示切换线程之后的observer其实相当于onnext等方法都被放在指定的线程里去发射数据">用一段伪代码来展示切换线程之后的observer，其实相当于onNext等方法都被放在指定的线程里去发射数据</h5>
<pre><code>public class Observer {
    Observer oldObserver;

    public Observer(Observer observer) {
        oldObserver = observer;
    }

    public void onNext(T t) {
        // 一些其他操作
        new Thread(&quot;Android mainThread&quot;) {
            @Override
            public void run() {
                oldObserver.onNext(t);
            }
        } .start();
    }

    public void onError(Throwable e) {
        // 一些其他操作
        new Thread(&quot;Android mainThread&quot;) {
            @Override
            public void run() {
                oldObserver.onError(e);
            }
        } .start();
    }

    public void onComplete() {
        // 一些其他操作
        new Thread(&quot;Android mainThread&quot;) {
            @Override
            public void run() {
                oldObserver.onComplete();
            }
        } .start();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Okhttp的Interceptor拦截器源码解析]]></title>
        <id>https://colaman0.github.io/kylelin/post/okhttp-de-interceptor-lan-jie-qi-yuan-ma-jie-xi/</id>
        <link href="https://colaman0.github.io/kylelin/post/okhttp-de-interceptor-lan-jie-qi-yuan-ma-jie-xi/">
        </link>
        <updated>2020-04-09T07:01:31.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="拦截器的作用在app开发中是相当重要的这篇文章分析一下okhttp中是怎么实现一条拦截器链希望能帮助大家更好去了解拦截器的作用">拦截器的作用在APP开发中是相当重要的，这篇文章分析一下Okhttp中是怎么实现一条拦截器链，希望能帮助大家更好去了解拦截器的作用</h4>
]]></summary>
        <content type="html"><![CDATA[<h4 id="拦截器的作用在app开发中是相当重要的这篇文章分析一下okhttp中是怎么实现一条拦截器链希望能帮助大家更好去了解拦截器的作用">拦截器的作用在APP开发中是相当重要的，这篇文章分析一下Okhttp中是怎么实现一条拦截器链，希望能帮助大家更好去了解拦截器的作用</h4>
<!-- more -->
<h3 id="几个关键类以及接口">几个关键类以及接口</h3>
<ul>
<li>
<h4 id="realinterceptorchain">RealInterceptorChain</h4>
</li>
<li>
<h4 id="interceptor">Interceptor</h4>
</li>
</ul>
<h3 id="realinterceptorchain-2">RealInterceptorChain</h3>
<h4 id="realinterceptorchain实现了interceptor接口调用源头来自于realcall的getresponsewithinterceptorchain方法"><code>RealInterceptorChain</code>实现了<code>Interceptor</code>接口,调用源头来自于<code>RealCall</code>的<code>getResponseWithInterceptorChain</code>方法</h4>
<pre><code class="language-java">  Response getResponseWithInterceptorChain() throws IOException {
    // Build a full stack of interceptors.
    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();
    /**
    *  1
    */
    interceptors.addAll(client.interceptors());
    interceptors.add(retryAndFollowUpInterceptor);
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    interceptors.add(new CacheInterceptor(client.internalCache()));
    interceptors.add(new ConnectInterceptor(client));
    if (!forWebSocket) {
      interceptors.addAll(client.networkInterceptors());
    }
    interceptors.add(new CallServerInterceptor(forWebSocket));
    /**
    *  2
    */
    Interceptor.Chain chain = new RealInterceptorChain(
        interceptors, null, null, null, 0, originalRequest);
    return chain.proceed(originalRequest);
  }
</code></pre>
<h4 id="1-第一处是把自定义的拦截器先加入进去然后把okhttp内置的一些拦截器按照功能顺序add进list里">1. 第一处是把自定义的拦截器先加入进去，然后把okhttp内置的一些拦截器按照功能顺序add进list里</h4>
<h4 id="2-第二处是整个拦截器工作的源头先new了一个realinterceptorchainindex为0把初始的request传了进去然后调用proceed获取请求的response">2. 第二处是整个拦截器工作的源头，先new了一个<code>RealInterceptorChain</code>,index为0，把初始的<code>request</code>传了进去,然后调用<code>proceed</code>获取请求的<code>response</code></h4>
<h4 id="接下来看一下proceed方法的具体实现忽略掉一些检查">接下来看一下proceed方法的具体实现,忽略掉一些检查</h4>
<pre><code class="language-java">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
      RealConnection connection) throws IOException {
    if (index &gt;= interceptors.size()) throw new AssertionError();

    calls++;
    /**
    *  1
    */
    // Call the next interceptor in the chain.
    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
        writeTimeout);
    Interceptor interceptor = interceptors.get(index);
    Response response = interceptor.intercept(next);

    return response;
  }
</code></pre>
<h5 id="先是检查一下index是否超出interceptors也就是拦截器list的长度接着又new了一个realinterceptorchain把当前realinterceptorchain的一些参数属性都传了进去并且在这里把index-1这个地方很重要在这里可以把realinterceptorchain想象成把拦截器给包装了起来然后用下一个拦截器生成一个新的realinterceptorchain中然后把index1下标的chain传进了当前拦截器的intercept方法里也就是我们自定义拦截器的时候需要重写的intercept方法也就是说我们添加的拦截器里的intercept方法中realinterceptorchain对象实际上里面包含有整个request以及下一个拦截器-所以就形成了一条链每一个拦截器都持有下一个拦截器经过包装之后的realinterceptorchain对象直到拦截器链的最后一个拦截器callserverinterceptor-这个拦截器会做最后的处理然后开始请求生成response并且返回-拦截器可以通过intercept方法获取下一个拦截器return的response而且会通过proceed方法向下一个拦截器传递自己处理过的requeset">先是检查一下index是否超出<code>interceptors</code>也就是拦截器list的长度，接着又new了一个<code>RealInterceptorChain</code>，把当前<code>RealInterceptorChain</code>的一些参数属性都传了进去，并且在这里把<code>index + 1</code>,这个地方很重要，在这里可以把<code>RealInterceptorChain</code>想象成把拦截器给包装了起来，然后用下一个拦截器生成一个新的<code>RealInterceptorChain</code>中，然后把<code>index+1</code>下标的<code>chain</code>传进了当前拦截器的<code>intercept</code>方法里，也就是我们自定义拦截器的时候需要重写的<code>intercept</code>方法，也就是说我们添加的拦截器里的<code>intercept</code>方法中<code>RealInterceptorChain</code>对象，实际上里面包含有整个<code>request</code>以及下一个拦截器。所以就形成了一条链，每一个拦截器都持有下一个拦截器经过包装之后的<code>RealInterceptorChain</code>对象,直到拦截器链的最后一个拦截器<code>CallServerInterceptor</code> 这个拦截器会做最后的处理，然后开始请求生成<code>Response</code>并且返回。拦截器可以通过<code>intercept</code>方法获取下一个拦截器<code>return</code>的<code>response</code>,而且会通过<code>proceed</code>方法向下一个拦截器传递自己处理过的<code>Requeset</code></h5>
<hr>
<h4 id="到这里总结一下各个方法以及类的作用">到这里总结一下各个方法以及类的作用</h4>
<ul>
<li>
<h4 id="realinterceptorchain-3">RealInterceptorChain</h4>
</li>
</ul>
<blockquote>
<p>包装了拦截器以及网络请求的信息</p>
</blockquote>
<ul>
<li>
<h4 id="realinterceptorchainproceed">RealInterceptorChain.proceed</h4>
</li>
</ul>
<blockquote>
<p>参数中有<code>Request</code>,是上一个拦截器包装过后的<code>Request</code>,然后将下一个拦截器和整个<code>Request</code>的信息包装成<code>RealInterceptorChain</code>，并且会调用当前拦截器的<code>intercept</code>方法把下一个拦截器(<code>RealInterceptorChain</code>)传进去，并且获取到<code>Response</code></p>
</blockquote>
<ul>
<li>
<h4 id="interceptorintercept">Interceptor.intercept</h4>
</li>
</ul>
<blockquote>
<p>方法参数是下一个<code>Chain</code>也就是<code>RealInterceptorChain</code>，然后调用<code>RealInterceptorChain.request()</code>去获取请求,调用<code>RealInterceptorChain.proceed()</code>去获取<code>Response</code></p>
</blockquote>
<h4 id="这三点结合在一起就形成了一条链假设有拦截器abcrealinterceptorchain-abc">这三点结合在一起，就形成了一条链，假设有拦截器A/B/C,RealInterceptorChain A/B/C</h4>
<h4 id="raproceed-aintercept调用下一个拦截器的proceed-rbproceed-bintercept这样的写法可以让每个拦截器都获取到上一个拦截器包装过的request并且自己处理之后再传给下一个拦截器然后最后一个拦截器生成response之后从拦截器链尾部往头部拦截器一层层return就形成了一个完整的拦截器链处理逻辑">RA.<code>proceed</code>-&gt;A.<code>intercept</code>（调用下一个拦截器的<code>proceed</code>）-&gt;RB.<code>proceed</code>-&gt;B.<code>intercept</code>，这样的写法，可以让每个拦截器都获取到上一个拦截器包装过的<code>Request</code>并且自己处理之后再传给下一个拦截器，然后最后一个拦截器生成<code>Response</code>之后，从拦截器链尾部往头部拦截器一层层return，就形成了一个完整的拦截器链处理逻辑</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个超高自定义度又简单使用的页面状态管理库]]></title>
        <id>https://colaman0.github.io/kylelin/post/yi-ge-chao-gao-zi-ding-yi-du-you-jian-dan-shi-yong-de-ye-mian-zhuang-tai-guan-li-ku/</id>
        <link href="https://colaman0.github.io/kylelin/post/yi-ge-chao-gao-zi-ding-yi-du-you-jian-dan-shi-yong-de-ye-mian-zhuang-tai-guan-li-ku/">
        </link>
        <updated>2020-04-09T07:00:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="statuslayout-一个超高自定义度又简单的页面状态管理库">StatusLayout  : 一个超高自定义度又简单的页面状态管理库</h1>
<h4 id="业务场景需求">业务场景需求：</h4>
<h4 id="在日常开发app的过程中我们少不了对activityfragment-等做一些不同状态不同ui的状态管理逻辑比如空页面-错误重试页面-等等网上也有很多作者写了开源库来处理这些问题-但是我看了一下这些库个人认为有以下几个小问题">在日常开发App的过程中，我们少不了对<code>Activity</code>/<code>Fragment</code> 等做一些不同状态不同UI的状态管理逻辑，比如<code>空页面</code> <code>错误重试页面</code> 等等，网上也有很多作者写了开源库来处理这些问题 但是我看了一下这些库，个人认为有以下几个小问题</h4>
<ul>
<li>
<h6 id="大部分都是只定义了错误-空数据-loading等3-5个左右的状态并且切换的时候也是已经规定好调用哪些方法这样就会大大限制了拓展性以及对一些复杂的业务场景的适配">大部分都是只定义了<code>错误</code> <code>空数据</code> <code>loading</code>等3-5个左右的状态，并且切换的时候也是已经规定好调用哪些方法，这样就会大大限制了拓展性以及对一些复杂的业务场景的适配</h6>
</li>
<li>
<h6 id="对于一些点击事件或者view的处理也不是很到位比如错误重试等大多数都是传入一个id">对于一些点击事件或者view的处理也不是很到位，比如错误重试等大多数都是传入一个id</h6>
</li>
<li>
<h6 id="多个地方需要同样的设置的时候需要不断copy代码过去">多个地方需要同样的设置的时候，需要不断copy代码过去</h6>
</li>
</ul>
<h5 id="以上几个小问题相信有些开发者也有发现在用的时候也会觉得还有改进的空间">以上几个小问题相信有些开发者也有发现，在用的时候也会觉得还有改进的空间</h5>
<h5 id="我在公司的项目中也发现了这些问题所以在空闲时间写了一个管理库用来管理页面接下来就给大家介绍一下相信能给大家在日常开发中带来更多便利更少的代码更多的可操作性">我在公司的项目中也发现了这些问题，所以在空闲时间写了一个管理库用来管理页面，接下来就给大家介绍一下，相信能给大家在日常开发中带来更多便利，更少的代码，更多的可操作性</h5>
<hr>
<h4 id="statuslayout有以下几个优点"><code>StatusLayout</code>有以下几个优点</h4>
<ul>
<li>
<h5 id="自由定制需要的状态以及对应布局只需要一行代码">自由定制需要的状态以及对应布局，只需要一行代码</h5>
</li>
<li>
<h5 id="可以定制动画效果">可以定制动画效果</h5>
</li>
<li>
<h5 id="可以用在旧项目上不需要修改原有xml文件">可以用在旧项目上，不需要修改原有xml文件</h5>
</li>
<li>
<h5 id="可设置全局属性避免重复劳动">可设置全局属性避免重复劳动</h5>
</li>
</ul>
<h4 id="github地址-httpsgithubcomcolaman0statuslayout">Github地址: https://github.com/Colaman0/StatusLayout</h4>
<hr>
<h4 id="效果图">效果图：</h4>
<img src="https://user-gold-cdn.xitu.io/2019/7/22/16c1a2e363765211?w=1080&h=1920&f=gif&s=4481569" width = "30%" />
<blockquote>
<p>效果图来看比起普通的库多了一个淡入淡出的动画效果，这部分可以自定义，这里只给大家展现一个最基本的效果</p>
</blockquote>
<h4 id="依赖">依赖 ：</h4>
<pre><code>    allprojects {
        repositories {
            ...
            maven { url 'https://jitpack.io' }
        }
    }
</code></pre>
<pre><code>	dependencies {
	        implementation 'com.github.Colaman0:StatusLayout:1.0.8'
	}
</code></pre>
<h4 id="具体使用步骤如下">具体使用步骤如下：</h4>
<h3 id="1第一步先把statuslayout作为根布局这里有以下两种写法">1.第一步先把<code>StatusLayout</code>作为根布局，这里有以下两种写法</h3>
<ul>
<li>
<h6 id="把statuslayout作为根布局在activityfragmentview-中使用">把<code>StatusLayout</code>作为根布局在activity/fragment/view 中使用</h6>
<blockquote>
<p>在xml内直接把<code>StatusLayout</code>作为根布局，注意<code>StatusLayout</code>内部子view数量不能超过1个，<br>
所以如果UI上需求需要排列多个View的时候，需要多套一层布局，比如：</p>
</blockquote>
<pre><code>&lt;StatusLayout&gt;
    &lt;LinearLayout&gt;    
        &lt;View/&gt;        
        &lt;View/&gt;
        &lt;View/&gt;
    &lt;/LinearLayout&gt;
&lt;/StatusLayout&gt;

</code></pre>
</li>
<li>
<h6 id="通过-statuslayoutinit方法传入context以及你要显示到的layout资源文件这个方法会返回一个statuslayout对象所以大家可以在封装baseactivity的时候这样写">通过 <code>StatusLayout.init()</code>方法传入Context以及你要显示到的layout资源文件，这个方法会返回一个StatusLayout对象，所以大家可以在封装BaseActivity的时候这样写:</h6>
<pre><code>// 后续可以通过mStatusLayout添加不同状态对应的UI  
StatusLayout mStatusLayout = StatusLayout.init(this, R.layout.activity_main);   
setContentView(mStatusLayout);
</code></pre>
</li>
</ul>
<h3 id="2-添加不同状态对应的ui以及响应点击事件">2. 添加不同状态对应的UI以及响应点击事件</h3>
<h6 id="通过addstatusconfig-statusconfig方法来添加一种状态布局传入statusconfig参数类给大家讲一下每个参数的作用">通过<code>add(statusconfig : StatusConfig)</code>方法来添加一种状态布局，传入<code>StatusConfig</code>参数类，给大家讲一下每个参数的作用</h6>
<ul>
<li>
<p><code>status</code> ： 作为一个状态布局的status标记，比如<code>空页面</code> <code>错误页面</code> 等等你想要添加进去的页面，设置一下自己想要添加的<code>status</code></p>
</li>
<li>
<p><code>layoutRes</code> : 对应上面的<code>status</code>， 一个<code>status</code>对应一个view，一个布局，比如上面<code>status</code>传入了一个empty，那我们这里对应可以添加一个空页面的layout资源文件id</p>
</li>
<li>
<p><code>view</code> ： 跟<code>layoutRes</code>相似，考虑到有时候业务需求，某个状态下的页面可能按钮或者一些需要写的逻辑比较多比较复杂， 这个时候可以让开发者自己写一个view传进来，对应的一些逻辑判断则让<code>view</code>内部去处理 ,<code>StatusLayout</code>只负责切换</p>
</li>
<li>
<p><code>clickRes</code> ：每一个布局，可以传递一个id进来，比如<code>错误重试页面</code> 可以传一个button的id进来，这样在button被点击的时候，可以通过回调来接收到点击事件</p>
<pre><code>  data class StatusConfig(        
          var status: String?,        
          @field:LayoutRes        
          var layoutRes: Int = -1,        
          var view: View? = null,       
          @field:IdRes       
          var clickRes: Int = -1)


</code></pre>
</li>
</ul>
<h3 id="3-切换布局">3. 切换布局</h3>
<h5 id="通过switchlayoutshowdefaultcontent两种方法来切换布局">通过<code>switchLayout()</code>/<code>showDefaultContent()</code>两种方法来切换布局</h5>
<ul>
<li><code>switchLayout(status : String)</code>方法是用于切换你add进去的布局，只要传入你前面add布局的时候传入的status就可以了</li>
<li><code>showDefaultContent()</code>用于切换回你默认的UI，比如在切到error状态的UI时，你点击了重试按钮请求成功之后，通过<code>showDefaultContent()</code>方法切换正常的布局，可能是你在xml里默认的一个布局，也可以是通过<code>add</code>方法添加进去的布局，通过<code>add</code>添加进去的布局需要<code>status</code>为<code>STATUS_NORMAL</code>才会被<code>StatusLayout</code>认为是默认的布局。总体来说切换回正常状态布局调用这个方法就可以了，具体可以参考下面关于回调的代码</li>
</ul>
<h3 id="4-不同布局点击的回调">4.  不同布局点击的回调</h3>
<p>上面在<code>add</code>方法中讲到了<code>StatusConfig</code>中一个<code>clickRes</code>变量，相当于告诉<code>StatusLayout</code>我要监听这个id的view的点击事件，当它被点击的时候告诉我，可以通过<code>setLayoutClickListener()</code>方法来设置监听</p>
<pre><code>            setLayoutClickListener(new StatusLayout.OnLayoutClickListener() {
                @Override
                public void OnLayoutClick(View view, String status) {
                     // View: 对应status的rootView  
                     // status:当前status,可以判断当前页面处于哪个status
                    switch (status) {
                        case LOADING:
                            Toast.makeText(MainActivity.this, LOADING, Toast.LENGTH_SHORT).show();
                            break;
                        case EMPTY:
                            Toast.makeText(MainActivity.this, EMPTY, Toast.LENGTH_SHORT).show();
                            break;
                        case ERROR:  
                             // 这里通过showDefaultContent()方法展示默认的布局
                            mStatusLayout.showDefaultContent();
                            break;
                    }
                }
            });
            
</code></pre>
<p>讲解一下上面的代码，设置一个layout点击的回调监听，当<code>layout/clickRes</code> 对应的view被点击的时候，会回调当前是哪一个status的页面，以及对应的布局view，当我们的<code>clickRes</code>不传的时候，默认是整个页面响应点击事件，所以在add的时候比较灵活的处理了关于点击事件的处理，比较复杂的页面建议就在<code>add</code>的时候传入一个<code>view</code>然后在内部做处理比较合适了，避免拓展出一大堆方法。</p>
<h3 id="5-设置显示隐藏的动画">5. 设置显示/隐藏的动画</h3>
<p>通过<code>setAnimation()</code> 来设置页面显示/隐藏的的动画, 也可以通过<code>setGlobalAnim()</code>来设置一个全局的动画效果，<code>setAnimation()</code>的优先级比<code>setGlobalAnim()</code>更高</p>
<h3 id="6设置全局属性">6.设置全局属性</h3>
<p>考虑到APP里常见的<code>空页面</code> <code>loading</code> 之类的页面都是比较统一的，这个时候可以通过<code>StatusLayout.setGlobalData()</code>方法来设置全局的属性，这个时候可以设置全局属性来避免重复添加的代码，后续可以通过<code>add（）</code>方法来覆盖全局属性。<br>
<code>setGlobalData</code>方法传入的参数和通过<code>add()</code>方法传入的参数值是一样的，可以参考一下代码，并且这里考虑到有些地方没有机会用到这些布局或者说不需要这些布局，所以<code>StatusLayout</code>只有在切换布局的时候才会去加载这些全局属性布局。</p>
<pre><code>StatusLayout.setGlobalData(        
    StatusConfig(status = StatusLayout.STATUS_EMPTY, layoutRes = R.layout.include_empty),        
    StatusConfig(status = StatusLayout.STATUS_ERROR, layoutRes = R.layout.include_error, clickRes = R.id.btn_retry))
</code></pre>
<h2 id="总结">总结</h2>
<h3 id="以上六点就讲解完了statuslayout的一个使用在我一开始写的时候是想着能尽量适应多种场景以及尽可能少的代码逻辑">以上六点就讲解完了<code>StatusLayout</code>的一个使用，在我一开始写的时候，是想着能尽量适应多种场景以及尽可能少的代码逻辑</h3>
<ul>
<li>
<h6 id="比如电商app中一个订单支付成功失败loading等场景可以通过statuslayout去对应添加布局并且对于一些通用的状态可以设置全局属性避免不同地方出现一样的代码并且以后需要更换布局的时候只要在设置全局属性的地方修改一下layout就可以了">比如电商APP中一个订单支付成功失败loading等场景，可以通过<code>StatusLayout</code>去对应添加布局，并且对于一些通用的状态，可以设置全局属性避免不同地方出现一样的代码，并且以后需要更换布局的时候只要在设置全局属性的地方修改一下layout就可以了。</h6>
</li>
<li>
<h5 id="点击回调通过setlayoutclicklistener-去处理不同状态下的点击事件回调不需要写不同的回调事件也可以更好的对于多种多样的布局来做一个适应">点击回调通过<code>setLayoutClickListener</code> 去处理不同状态下的点击事件回调，不需要写不同的回调事件，也可以更好的对于多种多样的布局来做一个适应</h5>
</li>
</ul>
<h4 id="整个库的核心想法就是通过status来管理页面statuslayout只负责管理你添加进来的布局以及对应切换某个status的布局-并不会限制得很死要调用某个方法所以你可以尽情得自定义你的页面添加各种各样的布局进去然后通过switchlayout来切换布局就可以了">整个库的核心想法就是通过<code>status</code>来管理页面，<code>StatusLayout</code>只负责管理你添加进来的布局，以及对应切换某个<code>status</code>的布局。并不会限制得很死要调用某个方法，所以你可以尽情得自定义你的页面，添加各种各样的布局进去，然后通过<code>switchLayout（）</code>来切换布局就可以了。</h4>
<hr>
<h4 id="github地址-httpsgithubcomcolaman0statuslayout-2">Github地址: https://github.com/Colaman0/StatusLayout</h4>
]]></content>
    </entry>
</feed>